{
  "CERT-C": {
    "FLP32-C": {
      "properties": {
        "obligation": "rule"
      },
      "queries": [
        {
          "description": "TODO.",
          "kind": "problem",
          "name": "Prevent or detect domain and range errors in math functions",
          "precision": "very-high",
          "severity": "error",
          "short_name": "PreventOrDetectDomainAndRangeErrorsInMathFunctions",
          "tags": []
        }
      ],
      "title": "Prevent or detect domain and range errors in math functions"
    },
    "FLP34-C": {
      "properties": {
        "obligation": "rule"
      },
      "queries": [
        {
          "description": "TODO.",
          "kind": "problem",
          "name": "Ensure that floating-point conversions are within range of the new type",
          "precision": "very-high",
          "severity": "error",
          "short_name": "FloatingPointConversionsNotWithinRangeOfNewType",
          "tags": []
        }
      ],
      "title": "Ensure that floating-point conversions are within range of the new type"
    },
    "FLP36-C": {
      "properties": {
        "obligation": "rule"
      },
      "queries": [
        {
          "description": "TODO.",
          "kind": "problem",
          "name": "Preserve precision when converting integral values to floating-point type",
          "precision": "very-high",
          "severity": "error",
          "short_name": "FloatingPointOfIntegralValuesLosePrecision",
          "tags": []
        }
      ],
      "title": "Preserve precision when converting integral values to floating-point type"
    },
    "FLP37-C": {
      "properties": {
        "obligation": "rule"
      },
      "queries": [
        {
          "description": "TODO.",
          "kind": "problem",
          "name": "Do not use object representations to compare floating-point values",
          "precision": "very-high",
          "severity": "error",
          "short_name": "ObjectReprUsedForComparingFloatingPointValues",
          "tags": []
        }
      ],
      "title": "Do not use object representations to compare floating-point values"
    },
    "INT30-C": {
      "properties": {
        "obligation": "rule"
      },
      "queries": [
        {
          "description": "TODO.",
          "kind": "problem",
          "name": "Ensure that unsigned integer operations do not wrap",
          "precision": "high",
          "severity": "error",
          "short_name": "EnsureThatUnsignedIntegerOperationsDoNotWrap",
          "tags": []
        }
      ],
      "title": "Ensure that unsigned integer operations do not wrap"
    },
    "INT31-C": {
      "properties": {
        "obligation": "rule"
      },
      "queries": [
        {
          "description": "TODO.",
          "kind": "problem",
          "name": "Ensure that integer conversions do not result in lost or misinterpreted data",
          "precision": "high",
          "severity": "error",
          "short_name": "IntConversionCausesLostOrMisinterpretedData",
          "tags": []
        }
      ],
      "title": "Ensure that integer conversions do not result in lost or misinterpreted data"
    },
    "INT32-C": {
      "properties": {
        "obligation": "rule"
      },
      "queries": [
        {
          "description": "TODO.",
          "kind": "problem",
          "name": "Ensure that operations on signed integers do not result in overflow",
          "precision": "high",
          "severity": "error",
          "short_name": "OperationsOnSignedIntegersResultsInOverflow",
          "tags": []
        }
      ],
      "title": "Ensure that operations on signed integers do not result in overflow"
    },
    "INT33-C": {
      "properties": {
        "obligation": "rule"
      },
      "queries": [
        {
          "description": "TODO.",
          "kind": "problem",
          "name": "Ensure that division and remainder operations do not result in divide-by-zero errors",
          "precision": "high",
          "severity": "error",
          "short_name": "DivAndModOperationResultsInDivByZero",
          "tags": []
        }
      ],
      "title": "Ensure that division and remainder operations do not result in divide-by-zero errors"
    },
    "INT34-C": {
      "properties": {
        "obligation": "rule"
      },
      "queries": [
        {
          "description": "Do not shift an expression by a negative number of bits or by greater than or equal to the number of bits that exist in the operand.",
          "kind": "problem",
          "name": "Do not shift an expression by a negative number of bits or by greater than or equal to the number of",
          "precision": "very-high",
          "severity": "error",
          "short_name": "ExprShiftedByNegativeBitsOrGreaterThanOperand",
          "tags": []
        }
      ],
      "title": "Do not shift an expression by a negative number of bits or by greater than or equal to the number of bits that exist in the operand"
    },
    "INT35-C": {
      "properties": {
        "obligation": "rule"
      },
      "queries": [
        {
          "description": "TODO.",
          "kind": "problem",
          "name": "Use correct integer precisions",
          "precision": "high",
          "severity": "error",
          "short_name": "UseCorrectIntegerPrecisions",
          "tags": []
        }
      ],
      "title": "Use correct integer precisions"
    },
    "INT36-C": {
      "properties": {
        "obligation": "rule"
      },
      "queries": [
        {
          "description": "TODO.",
          "kind": "problem",
          "name": "Converting a pointer to integer or integer to pointer",
          "precision": "very-high",
          "severity": "error",
          "short_name": "ConvertingAPointerToIntegerOrIntegerToPointer",
          "tags": []
        }
      ],
      "title": "Converting a pointer to integer or integer to pointer"
    }
  },
  "MISRA-C-2012": {
    "DIR-4-6": {
      "properties": {
        "obligation": "advisory"
      },
      "queries": [
        {
          "description": "TODO.",
          "kind": "problem",
          "name": "typedefs that indicate size and signedness should be used in place of the basic numerical types",
          "precision": "high",
          "severity": "error",
          "short_name": "NumericTypedefsNotUsedInPlaceOfBasicNumericalTypes",
          "tags": []
        }
      ],
      "title": "typedefs that indicate size and signedness should be used in place of the basic numerical types"
    },
    "RULE-10-1": {
      "properties": {
        "obligation": "required"
      },
      "queries": [
        {
          "description": "TODO.",
          "kind": "problem",
          "name": "Operands shall not be of an inappropriate essential type",
          "precision": "high",
          "severity": "error",
          "short_name": "OperandsOfAnInappropriateEssentialType",
          "tags": []
        }
      ],
      "title": "Operands shall not be of an inappropriate essential type"
    },
    "RULE-10-2": {
      "properties": {
        "obligation": "required"
      },
      "queries": [
        {
          "description": "Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations.",
          "kind": "problem",
          "name": "Expressions of essentially character type shall not be used inappropriately in addition and",
          "precision": "very-high",
          "severity": "error",
          "short_name": "CharTypeExprsUsedInAddOrSub",
          "tags": []
        }
      ],
      "title": "Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations"
    },
    "RULE-10-3": {
      "properties": {
        "obligation": "required"
      },
      "queries": [
        {
          "description": "The value of an expression shall not be assigned to an object with a narrower essential type or of a different essential type category.",
          "kind": "problem",
          "name": "The value of an expression shall not be assigned to an object with a narrower essential type or of a",
          "precision": "high",
          "severity": "error",
          "short_name": "AssignmentToIncompatibleEssentialType",
          "tags": []
        }
      ],
      "title": "The value of an expression shall not be assigned to an object with a narrower essential type or of a different essential type category"
    },
    "RULE-10-4": {
      "properties": {
        "obligation": "required"
      },
      "queries": [
        {
          "description": "Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category.",
          "kind": "problem",
          "name": "Both operands of an operator in which the usual arithmetic conversions are performed shall have the",
          "precision": "very-high",
          "severity": "error",
	  "short_name": "ArithConversionOperandHasDifferentEssTypeCategory",
          "tags": []
        }
      ],
      "title": "Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category"
    },
    "RULE-10-5": {
      "properties": {
        "obligation": "advisory"
      },
      "queries": [
        {
          "description": "TODO.",
          "kind": "problem",
          "name": "The value of an expression should not be cast to an inappropriate essential type",
          "precision": "very-high",
          "severity": "error",
          "short_name": "ValueCastToInappropriateEssentialType",
          "tags": []
        }
      ],
      "title": "The value of an expression should not be cast to an inappropriate essential type"
    },
    "RULE-10-6": {
      "properties": {
        "obligation": "required"
      },
      "queries": [
        {
          "description": "TODO.",
          "kind": "problem",
          "name": "The value of a composite expression shall not be assigned to an object with wider essential type",
          "precision": "very-high",
          "severity": "error",
          "short_name": "CompositeExprValueAssignedToObjWithWiderEssType",
          "tags": []
        }
      ],
      "title": "The value of a composite expression shall not be assigned to an object with wider essential type"
    },
    "RULE-10-7": {
      "properties": {
        "obligation": "required"
      },
      "queries": [
        {
          "description": "If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type.",
          "kind": "problem",
          "name": "If a composite expression is used as one operand of an operator in which the usual arithmetic",
          "precision": "very-high",
          "severity": "error",
          "short_name": "ConvertedCompExprOperandHasWiderEssTypeThanOther",
          "tags": []
        }
      ],
      "title": "If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type"
    },
    "RULE-10-8": {
      "properties": {
        "obligation": "required"
      },
      "queries": [
        {
          "description": "The value of a composite expression shall not be cast to a different essential type category or a wider essential type.",
          "kind": "problem",
          "name": "The value of a composite expression shall not be cast to a different essential type category or a",
          "precision": "very-high",
          "severity": "error",
          "short_name": "CompExprValCastToIncompatEssType",
          "tags": []
        }
      ],
      "title": "The value of a composite expression shall not be cast to a different essential type category or a wider essential type"
    },
    "RULE-12-4": {
      "properties": {
        "obligation": "advisory"
      },
      "queries": [
        {
          "description": "TODO.",
          "kind": "problem",
          "name": "Evaluation of constant expressions should not lead to unsigned integer wrap-around",
          "precision": "very-high",
          "severity": "error",
          "short_name": "ConstExprEvalCausesUnsignedIntWraparound",
          "tags": []
        }
      ],
      "title": "Evaluation of constant expressions should not lead to unsigned integer wrap-around"
    },
    "RULE-12-5": {
      "properties": {
        "obligation": "mandatory"
      },
      "queries": [
        {
          "description": "The sizeof operator shall not have an operand which is a function parameter declared as 'array of type'.",
          "kind": "problem",
          "name": "The sizeof operator shall not have an operand which is a function parameter declared as 'array of",
          "precision": "very-high",
          "severity": "error",
          "short_name": "ArrayTypeParamAtSizeofOperand",
          "tags": []
        }
      ],
      "title": "The sizeof operator shall not have an operand which is a function parameter declared as 'array of type'"
    },
    "RULE-14-1": {
      "properties": {
        "obligation": "required"
      },
      "queries": [
        {
          "description": "TODO.",
          "kind": "problem",
          "name": "A loop counter shall not have essentially floating type",
          "precision": "high",
          "severity": "error",
          "short_name": "LoopCounterHaveEssentiallyFloatingType",
          "tags": []
        }
      ],
      "title": "A loop counter shall not have essentially floating type"
    },
    "RULE-21-13": {
      "properties": {
        "obligation": "mandatory"
      },
      "queries": [
        {
          "description": "Any value passed to a function in <ctype.h> shall be representable as an unsigned char or be the value EOF.",
          "kind": "problem",
          "name": "Any value passed to a function in <ctype.h> shall be representable as an unsigned char or be the",
          "precision": "very-high",
          "severity": "error",
          "short_name": "CtypeFuncNeitherReprAsUnsignedCharNorEOF",
          "tags": []
        }
      ],
      "title": "Any value passed to a function in <ctype.h> shall be representable as an unsigned char or be the value EOF"
    },
    "RULE-21-14": {
      "properties": {
        "obligation": "required"
      },
      "queries": [
        {
          "description": "TODO.",
          "kind": "problem",
          "name": "The Standard Library function memcmp shall not be used to compare null terminated strings",
          "precision": "high",
          "severity": "error",
          "short_name": "MemcmpUsedToCompareNullTerminatedStrings",
          "tags": []
        }
      ],
      "title": "The Standard Library function memcmp shall not be used to compare null terminated strings"
    },
    "RULE-21-15": {
      "properties": {
        "obligation": "required"
      },
      "queries": [
        {
          "description": "The pointer arguments to the Standard Library functions memcpy, memmove and memcmp shall be pointers to qualified or unqualified versions of compatible types.",
          "kind": "problem",
          "name": "The pointer arguments to the Standard Library functions memcpy, memmove and memcmp shall be pointers",
          "precision": "very-high",
          "severity": "error",
          "short_name": "MemcpyMemmoveMemcmpArgNotPointerToCompatTypes",
          "tags": []
        }
      ],
      "title": "The pointer arguments to the Standard Library functions memcpy, memmove and memcmp shall be pointers to qualified or unqualified versions of compatible types"
    },
    "RULE-21-16": {
      "properties": {
        "obligation": "required"
      },
      "queries": [
        {
          "description": "The pointer arguments to the Standard Library function memcmp shall point to either a pointer type, an essentially signed type, an essentially unsigned type, an essentially Boolean type or an essentially enum type.",
          "kind": "problem",
          "name": "The pointer arguments to the Standard Library function memcmp shall point to either a pointer type,",
          "precision": "very-high",
          "severity": "error",
          "short_name": "MemcmpArgNotPtsToSignedUnsignedBooleanEnumEssType",
          "tags": []
        }
      ],
      "title": "The pointer arguments to the Standard Library function memcmp shall point to either a pointer type, an essentially signed type, an essentially unsigned type, an essentially Boolean type or an essentially enum type."
    },
    "RULE-7-4": {
      "properties": {
        "obligation": "required"
      },
      "queries": [
        {
          "description": "A string literal shall not be assigned to an object unless the object's type is 'pointer to const-qualified char'.",
          "kind": "problem",
          "name": "A string literal shall not be assigned to an object unless the object's type is 'pointer to",
          "precision": "very-high",
          "severity": "error",
          "short_name": "StringLiteralAssignedToObjPtrToConstQualifiedChar",
          "tags": []
        }
      ],
      "title": "A string literal shall not be assigned to an object unless the object's type is 'pointer to const-qualified char'"
    }
  }
}
